# Иллюстрации алгоритмов для отчета

## 1. Naive алгоритм транспонирования

### Схема работы одного потока:

```
Исходная матрица (4×4):              Транспонированная матрица (4×4):
┌─────────────────────────┐          ┌─────────────────────────┐
│  a00  a01  a02  a03     │          │  a00  a10  a20  a30     │
│  a10  a11  a12  a13     │          │  a01  a11  a21  a31     │
│  a20  a21  a22  a23     │   ───>   │  a02  a12  a22  a32     │
│  a30  a31  a32  a33     │          │  a03  a13  a23  a33     │
└─────────────────────────┘          └─────────────────────────┘

Поток (row=1, col=2):
  Читает:  in[1][2] = a12
  Пишет:  out[2][1] = a12
```

### Распределение потоков по блокам:

```
Grid (2×2 блоков, каждый 2×2 потока):

Блок (0,0):              Блок (0,1):
┌─────────┐              ┌─────────┐
│ T(0,0)  │ T(0,1)       │ T(0,2)  │ T(0,3)
│ T(1,0)  │ T(1,1)       │ T(1,2)  │ T(1,3)
└─────────┘              └─────────┘

Блок (1,0):              Блок (1,1):
┌─────────┐              ┌─────────┐
│ T(2,0)  │ T(2,1)       │ T(2,2)  │ T(2,3)
│ T(3,0)  │ T(3,1)       │ T(3,2)  │ T(3,3)
└─────────┘              └─────────┘

T(row, col) - поток, обрабатывающий элемент [row][col]
```

### Проблема naive подхода:

```
Доступ к памяти:
  Чтение: in[row][col] - коалесцированный (хорошо)
  Запись: out[col][row] - НЕ коалесцированный (плохо!)

Пример для строки:
  Потоки читают:  a00, a01, a02, a03  ← соседние (хорошо)
  Потоки пишут:   a00, a10, a20, a30  ← разбросаны (плохо!)
```

---

## 2. Shared Memory алгоритм

### Этап 1: Чтение тайла в shared memory

```
Исходная матрица разбита на тайлы 32×32:

┌──────────────┬──────────────┬──────────────┐
│   Тайл (0,0) │   Тайл (0,1) │   Тайл (0,2) │
│    32×32     │    32×32     │    32×32     │
├──────────────┼──────────────┼──────────────┤
│   Тайл (1,0) │   Тайл (1,1) │   Тайл (1,2) │
│    32×32     │    32×32     │    32×32     │
└──────────────┴──────────────┴──────────────┘

Блок потоков (32×8 = 256 потоков) обрабатывает один тайл
```

### Этап 2: Коалесцированное чтение

```
Блок потоков читает тайл в shared memory:

Глобальная память (in):          Shared memory (tile):
┌─────────────────────┐          ┌─────────────────────┐
│ a00  a01  a02  ...  │          │ a00  a01  a02  ... │
│ a10  a11  a12  ...  │   ───>   │ a10  a11  a12  ... │
│ a20  a21  a22  ...  │          │ a20  a21  a22  ... │
│ ...  ...  ...  ...  │          │ ...  ...  ...  ... │
└─────────────────────┘          └─────────────────────┘

Потоки читают построчно:
  Thread (0,0) → a00
  Thread (0,1) → a01
  Thread (0,2) → a02
  ... (коалесцированный доступ - хорошо!)
```

### Этап 3: Транспонирование в shared memory

```
После __syncthreads():

Shared memory (tile):
┌─────────────────────┐
│ a00  a01  a02  ...  │  ← исходный порядок
│ a10  a11  a12  ...  │
│ a20  a21  a22  ...  │
│ ...  ...  ...  ...  │
└─────────────────────┘

При записи меняем индексы:
  tile[threadIdx.x][threadIdx.y] вместо tile[threadIdx.y][threadIdx.x]
  
Результат (транспонированный):
┌─────────────────────┐
│ a00  a10  a20  ...  │  ← транспонированный
│ a01  a11  a21  ...  │
│ a02  a12  a22  ...  │
│ ...  ...  ...  ...  │
└─────────────────────┘
```

### Этап 4: Коалесцированная запись

```
Shared memory → Глобальная память (out):

Shared memory:                  Глобальная память:
┌─────────────────────┐          ┌─────────────────────┐
│ a00  a10  a20  ...  │          │ a00  a10  a20  ... │
│ a01  a11  a21  ...  │   ───>   │ a01  a11  a21  ... │
│ a02  a12  a22  ...  │          │ a02  a12  a22  ... │
│ ...  ...  ...  ...  │          │ ...  ...  ...  ... │
└─────────────────────┘          └─────────────────────┘

Потоки пишут построчно:
  Thread (0,0) → a00
  Thread (0,1) → a10
  Thread (0,2) → a20
  ... (коалесцированный доступ - хорошо!)
```

### Преимущество padding в shared memory:

```
Без padding [32][32]:            С padding [32][33]:
┌─────────────────────┐          ┌─────────────────────┐
│ a00  a01  a02  ...  │          │ a00  a01  a02  ... │
│ a10  a11  a12  ...  │          │ a10  a11  a12  ... │
│ ...  ...  ...  ...  │          │ ...  ...  ...  ... │
└─────────────────────┘          └─────────────────────┘
     ↑                                ↑
Bank conflicts при чтении        Нет bank conflicts
по столбцам!                     благодаря padding!
```

---

## 3. Сравнение подходов

### Доступ к памяти:

```
Naive подход:
  Чтение:  ████████ (коалесцированное)
  Запись:  █ █ █ █  (не коалесцированное - медленно!)

Shared Memory подход:
  Чтение:  ████████ (коалесцированное)
  Shared:  ████████ (быстрая локальная память)
  Запись:  ████████ (коалесцированное - быстро!)
```

### Временная сложность:

```
CPU:              O(rows × cols) - последовательно
GPU Naive:        O(1) - параллельно, но медленный доступ
GPU Shared:       O(1) - параллельно, быстрый доступ
```

### Использование памяти:

```
Naive:
  Глобальная память: 2 × rows × cols × sizeof(float)
  Shared memory:     0

Shared Memory:
  Глобальная память: 2 × rows × cols × sizeof(float)
  Shared memory:     32 × 33 × sizeof(float) = 4224 байт на блок
```

---

## 4. Пример вычисления блоков и потоков

### Для матрицы 1000×1000:

#### Naive версия:
```
TILE_SIZE = 32
blockSize = (32, 32) = 1024 потока

gridX = (1000 + 32 - 1) / 32 = 1024 / 32 = 32 блока
gridY = (1000 + 32 - 1) / 32 = 32 блока

Всего блоков: 32 × 32 = 1024
Всего потоков: 1024 × 1024 = 1,048,576
```

#### Shared Memory версия:
```
TILE_DIM = 32
BLOCK_ROWS = 8
dimBlock = (32, 8) = 256 потоков

gridX = (1000 + 32 - 1) / 32 = 32 блока
gridY = (1000 + 32 - 1) / 32 = 32 блока

Всего блоков: 32 × 32 = 1024
Всего потоков: 1024 × 256 = 262,144
```

### Для матрицы 500×500:

#### Naive версия:
```
gridX = (500 + 32 - 1) / 32 = 531 / 32 = 16.59 → 17 блоков
gridY = (500 + 32 - 1) / 32 = 17 блоков

Всего блоков: 17 × 17 = 289
Всего потоков: 289 × 1024 = 295,936
```

#### Shared Memory версия:
```
gridX = (500 + 32 - 1) / 32 = 17 блоков
gridY = (500 + 32 - 1) / 32 = 17 блоков

Всего блоков: 17 × 17 = 289
Всего потоков: 289 × 256 = 73,984
```

---

## 5. Визуализация работы shared memory подхода

```
Шаг 1: Чтение тайла
┌─────────────────────────────────────┐
│  Глобальная память (in)             │
│  ┌──────────┐                        │
│  │ Тайл 0,0 │ ──коалесцированно──>   │
│  └──────────┘                        │
└─────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  Shared Memory (tile)                │
│  ┌──────────┐                        │
│  │  Тайл    │                        │
│  └──────────┘                        │
└─────────────────────────────────────┘

Шаг 2: Синхронизация
        __syncthreads()
        (все потоки ждут)

Шаг 3: Транспонирование
┌─────────────────────────────────────┐
│  Shared Memory (tile)                │
│  ┌──────────┐                        │
│  │ Трансп.  │ (меняем индексы)       │
│  └──────────┘                        │
└─────────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────────┐
│  Глобальная память (out)             │
│  ┌──────────┐                        │
│  │ Тайл 0,0 │ <──коалесцированно───  │
│  └──────────┘                        │
└─────────────────────────────────────┘
```

---
